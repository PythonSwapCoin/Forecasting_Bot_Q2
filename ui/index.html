<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Forecasting Bot Process Designer</title>
    <link
      rel="stylesheet"
      href="https://esm.sh/reactflow@11/dist/style.css"
    />
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 1.5rem 2rem 1rem;
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 64, 175, 0.6));
        backdrop-filter: blur(12px);
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }
      header h1 {
        margin: 0 0 0.5rem;
        font-size: clamp(1.75rem, 1.5rem + 1vw, 2.4rem);
        font-weight: 600;
        color: #f8fafc;
      }
      header p {
        margin: 0;
        max-width: 680px;
        color: rgba(226, 232, 240, 0.75);
        line-height: 1.5;
      }
      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(320px, 1fr);
        gap: 0;
        overflow: hidden;
      }
      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }
      }
      #root {
        flex: 1;
      }
      .flow-container {
        background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.18), transparent 40%),
          radial-gradient(circle at bottom right, rgba(8, 145, 178, 0.16), transparent 45%),
          #0f172a;
        border-right: 1px solid rgba(148, 163, 184, 0.12);
        position: relative;
      }
      .sidebar {
        background: rgba(15, 23, 42, 0.86);
        padding: 1.25rem 1.75rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        overflow-y: auto;
        border-left: 1px solid rgba(148, 163, 184, 0.12);
      }
      .sidebar h2 {
        margin: 0;
        font-size: 1.25rem;
        color: #bfdbfe;
      }
      .sidebar section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .chip {
        padding: 0.3rem 0.6rem;
        border-radius: 999px;
        border: 1px solid rgba(125, 211, 252, 0.35);
        color: #7dd3fc;
        font-size: 0.75rem;
        letter-spacing: 0.01em;
      }
      .section-title {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.16em;
        color: rgba(148, 163, 184, 0.75);
        margin-bottom: 0.2rem;
      }
      .card {
        background: rgba(30, 41, 59, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 16px;
        padding: 1rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        box-shadow: 0 18px 32px rgba(15, 23, 42, 0.35);
      }
      .card h3 {
        margin: 0;
        font-size: 1.1rem;
        color: #e0f2fe;
      }
      .card ul {
        margin: 0;
        padding-left: 1.2rem;
        color: rgba(226, 232, 240, 0.8);
      }
      .card ul li {
        margin: 0.2rem 0;
      }
      .card p {
        margin: 0;
        color: rgba(226, 232, 240, 0.8);
        line-height: 1.5;
      }
      button.primary {
        align-self: flex-start;
        padding: 0.55rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(59, 130, 246, 0.5);
        background: rgba(37, 99, 235, 0.15);
        color: #93c5fd;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.3s ease, border 0.3s ease;
      }
      button.primary:hover {
        background: rgba(59, 130, 246, 0.25);
        border-color: rgba(147, 197, 253, 0.8);
      }
      .summary {
        display: grid;
        gap: 0.75rem;
      }
      .summary-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
        color: rgba(226, 232, 240, 0.85);
      }
      .badge {
        padding: 0.3rem 0.5rem;
        border-radius: 0.6rem;
        background: rgba(14, 165, 233, 0.2);
        color: #38bdf8;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Forecasting Bot Process Designer</h1>
      <p>
        Visualize the forecasting committee pipeline, inspect available tooling, and plan custom workflows.
        This interactive map mirrors the production agents that power the Metaculus tournament bot and lays the groundwork for future drag-and-drop editing.
      </p>
    </header>
    <main>
      <div id="root"></div>
    </main>
    <script type="module">
      import React, { useEffect, useState } from "https://esm.sh/react@18.3.1";
      import { createRoot } from "https://esm.sh/react-dom@18.3.1/client";
      import ReactFlow, {
        Background,
        BackgroundVariant,
        Controls,
        MiniMap,
        useEdgesState,
        useNodesState,
      } from "https://esm.sh/reactflow@11.11.2";

      const palette = {
        ingest: { border: "#38bdf8", fill: "rgba(14, 165, 233, 0.18)" },
        analysis: { border: "#a78bfa", fill: "rgba(167, 139, 250, 0.18)" },
        forecaster: { border: "#f59e0b", fill: "rgba(245, 158, 11, 0.16)" },
        tooling: { border: "#34d399", fill: "rgba(52, 211, 153, 0.16)" },
        summary: { border: "#60a5fa", fill: "rgba(96, 165, 250, 0.22)" },
      };

      const nodeStyle = (group) => ({
        borderRadius: 14,
        padding: 12,
        border: `1.5px solid ${palette[group].border}`,
        background: palette[group].fill,
        backdropFilter: "blur(4px)",
        color: "#f8fafc",
        fontSize: "0.9rem",
        fontWeight: 500,
      });

      const flows = {
        customForecast: {
          label: "custom_forecast.py (CLI run)",
          description:
            "Visualises the ad-hoc CLI that lets analysts craft a bespoke question, route it through the appropriate forecaster, and persist the commentary to disk.",
          nodes: [
            {
              id: "gather-input",
              position: { x: -420, y: -40 },
              data: { label: "Gather user input" },
              style: nodeStyle("ingest"),
            },
            {
              id: "create-structure",
              position: { x: -140, y: -40 },
              data: { label: "Create question structure" },
              style: nodeStyle("analysis"),
            },
            {
              id: "route-forecaster",
              position: { x: 120, y: -40 },
              data: { label: "Route to forecast fn" },
              style: nodeStyle("analysis"),
            },
            {
              id: "binary-forecaster",
              position: { x: 360, y: -200 },
              data: { label: "binary_forecast" },
              style: nodeStyle("forecaster"),
            },
            {
              id: "numeric-forecaster",
              position: { x: 360, y: -40 },
              data: { label: "numeric_forecast" },
              style: nodeStyle("forecaster"),
            },
            {
              id: "mc-forecaster",
              position: { x: 360, y: 120 },
              data: { label: "multiple_choice_forecast" },
              style: nodeStyle("forecaster"),
            },
            {
              id: "persist-output",
              position: { x: 620, y: -40 },
              data: { label: "Persist results" },
              style: nodeStyle("tooling"),
            },
            {
              id: "surface-results",
              position: { x: 860, y: -40 },
              data: { label: "Surface output" },
              style: nodeStyle("summary"),
            },
          ],
          edges: [
            { id: "c1", source: "gather-input", target: "create-structure" },
            { id: "c2", source: "create-structure", target: "route-forecaster" },
            { id: "c3", source: "route-forecaster", target: "binary-forecaster" },
            { id: "c4", source: "route-forecaster", target: "numeric-forecaster" },
            { id: "c5", source: "route-forecaster", target: "mc-forecaster" },
            { id: "c6", source: "binary-forecaster", target: "persist-output" },
            { id: "c7", source: "numeric-forecaster", target: "persist-output" },
            { id: "c8", source: "mc-forecaster", target: "persist-output" },
            { id: "c9", source: "persist-output", target: "surface-results" },
          ],
          knowledge: {
            "gather-input": {
              title: "Gather user input",
              description:
                "Interactive CLI that collects the title, description, resolution criteria, and type-specific metadata (ranges or options).",
              tools: ["Python input prompts", "Validation loops"],
              outputs: ["question_params dict", "Console transcript"],
            },
            "create-structure": {
              title: "Create question structure",
              description:
                "`create_question_structure` normalises raw answers into the schema expected by downstream forecasters, enriching numeric and multiple choice payloads with scaling or options.",
              tools: ["create_question_structure"],
              outputs: ["question_details payload", "Type metadata"],
            },
            "route-forecaster": {
              title: "Route to forecast function",
              description:
                "Dispatch logic in `forecast_custom_question` selects the appropriate coroutine based on the question type and forwards a file-aware writer callback.",
              tools: ["forecast_custom_question"],
              outputs: ["Selected coroutine", "Write hook"],
            },
            "binary-forecaster": {
              title: "binary_forecast",
              description:
                "Harnesses the binary forecasting stack (committee agents, retrieval, synthesis) to produce probabilities and commentary for yes/no questions.",
              tools: ["binary_forecast"],
              outputs: ["Final binary probability", "Narrative commentary"],
            },
            "numeric-forecaster": {
              title: "numeric_forecast",
              description:
                "Runs the numeric pipeline, consuming scaling information to estimate distributions and produce percentile guidance.",
              tools: ["numeric_forecast"],
              outputs: ["Point & distribution forecast", "Numeric rationale"],
            },
            "mc-forecaster": {
              title: "multiple_choice_forecast",
              description:
                "Scores each provided option, blending inside/outside-view reasoning before emitting calibrated probabilities.",
              tools: ["multiple_choice_forecast"],
              outputs: ["Option probability map", "Comparative analysis"],
            },
            "persist-output": {
              title: "Persist results",
              description:
                "Streams question details, forecasts, and commentary into a timestamped text artefact inside `custom_forecasts/`.",
              tools: ["write_to_file helper", "Filesystem"],
              outputs: ["Structured text report", "Write logs"],
            },
            "surface-results": {
              title: "Surface output",
              description:
                "Echoes the saved file path and key outputs back to the CLI so an analyst can review or share.",
              tools: ["Console print"],
              outputs: ["Terminal summary", "Saved artefact path"],
            },
          },
        },
        productionWorkflow: {
          label: "Tournament pipeline (Metaculus)",
          description:
            "Shows the always-on tournament pipeline that harvests questions, performs research, and aggregates committee forecasts.",
          nodes: [
            {
              id: "question-intake",
              position: { x: -350, y: 0 },
              data: { label: "Question intake" },
              style: nodeStyle("ingest"),
            },
            {
              id: "query-generation",
              position: { x: -120, y: -100 },
              data: { label: "Query generation" },
              style: nodeStyle("analysis"),
            },
            {
              id: "retrieval",
              position: { x: 150, y: -160 },
              data: { label: "Evidence retrieval" },
              style: nodeStyle("tooling"),
            },
            {
              id: "synthesis",
              position: { x: 150, y: 0 },
              data: { label: "Context synthesis" },
              style: nodeStyle("analysis"),
            },
            {
              id: "inside-view",
              position: { x: 450, y: -140 },
              data: { label: "Inside-view forecasters" },
              style: nodeStyle("forecaster"),
            },
            {
              id: "outside-view",
              position: { x: 450, y: 120 },
              data: { label: "Outside-view forecasters" },
              style: nodeStyle("forecaster"),
            },
            {
              id: "ensemble",
              position: { x: 700, y: -20 },
              data: { label: "Ensemble aggregator" },
              style: nodeStyle("summary"),
            },
            {
              id: "reporting",
              position: { x: 960, y: -20 },
              data: { label: "Reporting & submission" },
              style: nodeStyle("summary"),
            },
          ],
          edges: [
            { id: "e1", source: "question-intake", target: "query-generation" },
            { id: "e2", source: "question-intake", target: "synthesis" },
            { id: "e3", source: "query-generation", target: "retrieval" },
            { id: "e4", source: "retrieval", target: "synthesis" },
            { id: "e5", source: "synthesis", target: "inside-view" },
            { id: "e6", source: "synthesis", target: "outside-view" },
            { id: "e7", source: "inside-view", target: "ensemble" },
            { id: "e8", source: "outside-view", target: "ensemble" },
            { id: "e9", source: "ensemble", target: "reporting" },
          ],
          knowledge: {
            "question-intake": {
              title: "Question intake",
              description:
                "Pulls tournament questions, normalises metadata, and routes based on type.",
              tools: ["Metaculus GraphQL API", "Question templating"],
              outputs: ["Normalised question object", "Initial context memo"],
            },
            "query-generation": {
              title: "Query generation agents",
              description:
                "Dual-agent prompt pair generates research queries with complementary recall/precision focus.",
              tools: ["Claude 3.7 Sonnet", "GPT-o4-mini"],
              outputs: ["Search directives", "Tool selection hints"],
            },
            retrieval: {
              title: "Evidence retrieval",
              description:
                "Orchestrates AskNews, Exa, and Perplexity fetchers plus in-house scraping to build a research packet.",
              tools: ["AskNews SDK", "Exa Smart Searcher", "Custom scraper"],
              outputs: ["Ranked articles", "Snippets with source metadata"],
            },
            synthesis: {
              title: "Context synthesis",
              description:
                "Merges retrieved evidence, deduplicates insights, and curates highlights for downstream forecasters.",
              tools: ["LLM summarisers", "Relevance scoring"],
              outputs: ["Unified briefing", "Evidence heatmap"],
            },
            "inside-view": {
              title: "Inside-view forecasters",
              description:
                "Mechanistic analysts focus on causal chains, timelines, and scenario stress tests for each outcome.",
              tools: ["GPT-o4-mini", "Scenario planner prompts"],
              outputs: ["Probability estimates", "Rationale excerpts"],
            },
            "outside-view": {
              title: "Outside-view forecasters",
              description:
                "Reference-class agents blend historical baselines, trend extrapolation, and statistical heuristics.",
              tools: ["Claude 3.7 Sonnet", "Historical benchmark library"],
              outputs: ["Probability estimates", "Reference-class justification"],
            },
            ensemble: {
              title: "Ensemble aggregator",
              description:
                "Applies reliability weights, calibration adjustments, and sanity checks across the committee outputs.",
              tools: ["Reliability weighting", "Calibration curves"],
              outputs: ["Final probability", "Confidence report"],
            },
            reporting: {
              title: "Reporting & submission",
              description:
                "Posts forecasts, comments, and scratchpad artefacts back to Metaculus or experiment sandboxes.",
              tools: ["Metaculus API", "Auto-commentary generator"],
              outputs: ["Metaculus submission", "Public summary"],
            },
          },
        },
      };

      const SummaryPanel = ({ node, flowId }) => {
        const info = flows[flowId]?.knowledge?.[node?.id];
        if (!info) {
          return (
            <div className="card">
              <h3>Select a step</h3>
              <p>Click a node to inspect its responsibilities, tooling, and outputs.</p>
            </div>
          );
        }

        return (
          <div className="card">
            <h3>{info.title}</h3>
            <p>{info.description}</p>
            <section>
              <span className="section-title">Key tooling</span>
              <div className="chip-row">
                {info.tools.map((tool) => (
                  <span className="chip" key={tool}>
                    {tool}
                  </span>
                ))}
              </div>
            </section>
            <section>
              <span className="section-title">Primary outputs</span>
              <ul>
                {info.outputs.map((output) => (
                  <li key={output}>{output}</li>
                ))}
              </ul>
            </section>
          </div>
        );
      };

      const Roadmap = () => (
        <div className="card">
          <h3>Roadmap toward live editing</h3>
          <div className="summary">
            <div className="summary-item">
              <span>Drag-and-drop layout</span>
              <span className="badge">Next</span>
            </div>
            <div className="summary-item">
              <span>Connectors to configure tools per step</span>
              <span className="badge">Planned</span>
            </div>
            <div className="summary-item">
              <span>Versioned workflow exports</span>
              <span className="badge">Planned</span>
            </div>
            <div className="summary-item">
              <span>Live pipeline execution</span>
              <span className="badge">Future</span>
            </div>
          </div>
        </div>
      );

      const Layout = () => {
        const [flowId, setFlowId] = useState("customForecast");
        const [nodes, setNodes, onNodesChange] = useNodesState(flows["customForecast"].nodes);
        const [edges, setEdges, onEdgesChange] = useEdgesState(flows["customForecast"].edges);
        const [selectedNode, setSelectedNode] = useState(flows["customForecast"].nodes[0]);

        useEffect(() => {
          const flow = flows[flowId];
          setNodes(flow.nodes.map((node) => ({ ...node })));
          setEdges(flow.edges.map((edge) => ({ ...edge })));
          setSelectedNode(flow.nodes[0]);
        }, [flowId, setNodes, setEdges]);

        const onNodeClick = (_, node) => {
          setSelectedNode(node);
        };

        const addPlaceholderNode = () => {
          const id = `draft-${nodes.length + 1}`;
          const newNode = {
            id,
            data: { label: "Draft step" },
            position: { x: 250, y: nodes.length * 60 - 120 },
            style: nodeStyle("analysis"),
          };
          setNodes((nds) => [...nds, newNode]);
          setSelectedNode(newNode);
        };

        return (
          <div style={{ display: "contents" }}>
            <div className="flow-container">
              <div
                style={{
                  position: "absolute",
                  top: 16,
                  left: 16,
                  zIndex: 10,
                  display: "flex",
                  gap: "0.5rem",
                  alignItems: "center",
                  background: "rgba(15,23,42,0.85)",
                  border: "1px solid rgba(148, 163, 184, 0.28)",
                  borderRadius: 999,
                  padding: "0.35rem 0.75rem",
                  boxShadow: "0 12px 24px rgba(15, 23, 42, 0.4)",
                }}
              >
                <span style={{ fontSize: "0.75rem", letterSpacing: "0.08em", textTransform: "uppercase", color: "rgba(191,219,254,0.85)" }}>
                  Flow
                </span>
                <select
                  value={flowId}
                  onChange={(event) => setFlowId(event.target.value)}
                  style={{
                    background: "transparent",
                    border: "none",
                    color: "#e2e8f0",
                    fontSize: "0.85rem",
                    fontWeight: 500,
                    outline: "none",
                    padding: "0.25rem 0.1rem",
                    appearance: "none",
                  }}
                >
                  {Object.entries(flows).map(([id, flow]) => (
                    <option key={id} value={id} style={{ color: "#0f172a" }}>
                      {flow.label}
                    </option>
                  ))}
                </select>
              </div>
              <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onNodeClick={onNodeClick}
                panOnScroll
                fitView
                fitViewOptions={{ padding: 0.2 }}
              >
                <Background color="rgba(148, 163, 184, 0.25)" variant={BackgroundVariant.Dots} />
                <MiniMap pannable zoomable style={{ background: "rgba(15,23,42,0.9)" }} />
                <Controls showInteractive={false} />
              </ReactFlow>
            </div>
            <aside className="sidebar">
              <div className="card">
                <h3>{flows[flowId].label}</h3>
                <p>{flows[flowId].description}</p>
              </div>
              <SummaryPanel node={selectedNode} flowId={flowId} />
              <Roadmap />
              <button className="primary" onClick={addPlaceholderNode}>
                Add placeholder step
              </button>
              <div className="card">
                <h3>How to iterate</h3>
                <p>
                  This first version focuses on visualizing the production workflow. The hooks powering node and edge state are already wired for future editing experiences: drag handles, custom node drawers, and persistence APIs can be layered in without reworking the architecture.
                </p>
              </div>
            </aside>
          </div>
        );
      };

      const root = createRoot(document.getElementById("root"));
      root.render(<Layout />);
    </script>
  </body>
</html>
